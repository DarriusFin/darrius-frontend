<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>DarriusAI · Inflection Hunter</title>

  <!-- Plotly (for chart + B/S overlay) -->
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>

  <style>
    :root{
      --bg:#071018;
      --panel:#0b1621;
      --panel2:#0a131c;
      --line:#142434;
      --text:#d6e2f1;
      --muted:#8aa0b7;
      --good:#2ee59d;
      --bad:#ff5c6c;
      --warn:#ffcc66;
      --btn:#1b9cff;
      --btn2:#2ee59d;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:14px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,"PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif;
      background: radial-gradient(1200px 600px at 20% 0%, rgba(46,229,157,.10), transparent 60%),
                  radial-gradient(900px 500px at 80% 0%, rgba(27,156,255,.10), transparent 60%),
                  var(--bg);
      color:var(--text);
    }

    header{
      height:56px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 0 18px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(10,19,28,.85), rgba(10,19,28,.55));
      position: sticky;
      top:0;
      z-index:5;
      backdrop-filter: blur(10px);
    }
    .brand{
      display:flex;align-items:center;gap:10px;
      font-weight:700; letter-spacing:.2px;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background: var(--good);
      box-shadow: 0 0 14px rgba(46,229,157,.7);
    }
    .badge{
      font-size:12px;
      padding: 6px 10px;
      border:1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      color: var(--muted);
      background: rgba(255,255,255,.03);
      display:flex;align-items:center;gap:8px;
    }
    .api-pill{
      width:8px;height:8px;border-radius:50%;
      background: var(--good);
    }
    .api-pill.off{ background: var(--bad); box-shadow: 0 0 10px rgba(255,92,108,.6); }
    .wrap{
      display:grid;
      grid-template-columns: 1fr 360px;
      gap: 14px;
      padding: 14px;
      max-width: 1500px;
      margin: 0 auto;
    }

    .card{
      background: linear-gradient(180deg, rgba(11,22,33,.90), rgba(11,22,33,.70));
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card-h{
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.07);
      display:flex; align-items:center; justify-content:space-between;
    }
    .card-h h3{ margin:0; font-size:14px; font-weight:700; color:#e7f1ff; }
    .card-b{ padding: 12px 14px; }

    /* Chart area */
    #chart{
      width:100%;
      height: calc(100vh - 56px - 28px);
      min-height: 560px;
    }
    .toolbar{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .pillbar{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .pill{
      cursor:pointer;
      user-select:none;
      font-size:12px;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      color: var(--muted);
      transition: .15s;
    }
    .pill.active{
      border-color: rgba(46,229,157,.35);
      color:#eafff6;
      background: rgba(46,229,157,.10);
    }

    /* Right panel */
    .field{ margin-bottom: 12px; }
    label{
      display:block;
      font-size:12px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    input, select{
      width:100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.15);
      color: var(--text);
      outline: none;
    }
    input::placeholder{ color: rgba(138,160,183,.7); }
    .row2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }

    .btn{
      width:100%;
      padding: 11px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      cursor:pointer;
      font-weight:700;
      transition:.15s;
    }
    .btn.primary{
      background: linear-gradient(180deg, rgba(27,156,255,.95), rgba(27,156,255,.75));
      border-color: rgba(27,156,255,.35);
      color:#04111c;
    }
    .btn.good{
      background: linear-gradient(180deg, rgba(46,229,157,.95), rgba(46,229,157,.75));
      border-color: rgba(46,229,157,.35);
      color:#04111c;
    }
    .btn.ghost{
      background: rgba(255,255,255,.04);
      color: var(--text);
    }
    .btn:active{ transform: translateY(1px); }

    .hint{
      font-size:12px;
      color: var(--muted);
      line-height:1.45;
    }
    .statusline{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.06);
      margin-bottom: 10px;
      font-size: 12px;
      color: var(--muted);
    }
    .status-badge{
      font-weight:800;
      padding: 5px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: #e7f1ff;
    }
    .status-badge.ok{
      border-color: rgba(46,229,157,.35);
      background: rgba(46,229,157,.10);
      color: #eafff6;
    }
    .status-badge.err{
      border-color: rgba(255,92,108,.35);
      background: rgba(255,92,108,.10);
      color: #ffe9ec;
    }

    /* Toast */
    #toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(10,19,28,.92);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: var(--shadow);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 13px;
      color: var(--text);
      display:none;
      max-width: 92vw;
      z-index: 20;
    }
    #toast .t-muted{ color: var(--muted); font-size:12px; margin-top:4px; }

    .small{
      font-size:12px;
      color: var(--muted);
    }

    @media (max-width: 1100px){
      .wrap{ grid-template-columns: 1fr; }
      #chart{ height: 62vh; min-height: 420px; }
    }
  </style>
</head>

<body>
<header>
  <div class="brand">
    <span class="dot"></span>
    <div>DarriusAI · Inflection Hunter</div>
  </div>
  <div class="badge" title="Backend connectivity">
    <span id="apiPill" class="api-pill"></span>
    <span id="apiText">API: checking…</span>
  </div>
</header>

<div class="wrap">

  <!-- Main chart -->
  <div class="card">
    <div class="card-h">
      <h3 id="chartTitle">Chart</h3>
      <div class="toolbar">
        <div class="pillbar" id="tfPills"></div>
      </div>
    </div>
    <div class="card-b" style="padding:0;">
      <div id="chart"></div>
    </div>
  </div>

  <!-- Right control panel -->
  <div class="card">
    <div class="card-h">
      <h3>Control Center</h3>
      <span class="small" id="buildInfo">v1</span>
    </div>
    <div class="card-b">

      <!-- Market selection -->
      <div class="field">
        <label>Symbol</label>
        <input id="symbolInput" value="BTCUSDT" placeholder="e.g. BTCUSDT, AAPL, SPY"/>
      </div>

      <div class="row2">
        <div class="field">
          <label>Timeframe</label>
          <select id="tfSelect"></select>
        </div>
        <div class="field" style="display:flex; align-items:end;">
          <button class="btn primary" id="loadBtn">Load</button>
        </div>
      </div>

      <div class="field">
        <div class="hint">EMA / AUX overlays can be toggled here (if your backend returns them).</div>
        <div class="row2" style="margin-top:10px;">
          <label style="display:flex;gap:8px;align-items:center;margin:0;">
            <input type="checkbox" id="toggleEMA" checked style="width:auto;"/>
            <span>EMA</span>
          </label>
          <label style="display:flex;gap:8px;align-items:center;margin:0;">
            <input type="checkbox" id="toggleAUX" checked style="width:auto;"/>
            <span>AUX</span>
          </label>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,.07); margin:14px 0;">

      <!-- Plans / subscription -->
      <div class="field">
        <div class="statusline">
          <div>
            <div style="color:#e7f1ff;font-weight:700;">Subscription</div>
            <div class="small" id="subLine">Status: Unknown</div>
          </div>
          <span id="plansHealth" class="status-badge">Plans</span>
        </div>

        <label>Plan</label>
        <select id="planSelect"></select>
        <div class="small" id="planError" style="margin-top:8px; display:none; color: #ffe9ec;">
          Plans config error: expected 4 plans.
        </div>
      </div>

      <div class="field">
        <label>User ID</label>
        <input id="userIdInput" placeholder="e.g. user_123" />
      </div>

      <div class="field">
        <label>Email (optional)</label>
        <input id="emailInput" placeholder="name@domain.com"/>
      </div>

      <button class="btn good" id="subActionBtn">Subscribe & Start</button>
      <div class="hint" style="margin-top:10px;">
        One button flow: creates Stripe Checkout Session, then access is enabled by webhook.
      </div>

    </div>
  </div>

</div>

<div id="toast"></div>

<script>
/** =========================
 *  CONFIG — adjust if needed
 *  ========================= */
const API_BASE = ""; // same origin by default. If your API is on another domain, set it here.
const PRICES_ENDPOINT = `${API_BASE}/billing/prices`; // must return array of 4 plans
const CHECKOUT_ENDPOINT = `${API_BASE}/create-checkout-session`; // POST
const MARKET_ENDPOINT = `${API_BASE}/api/market`; // GET ?symbol=BTCUSDT&tf=1d (change if your backend differs)
const HEALTH_ENDPOINT = `${API_BASE}/`; // used to test API is alive

/** Timeframes required by your spec (8 options) */
const TIMEFRAMES = [
  { key:'5m', label:'5m'  },
  { key:'15m', label:'15m'},
  { key:'30m', label:'30m'},
  { key:'1h', label:'1h' },
  { key:'4h', label:'4h' },
  { key:'1d', label:'1D' },
  { key:'1w', label:'1W' },
  { key:'1m', label:'1M' },
];

const TF_FALLBACK = '1d';

/** Fixed expected plan order (stable rendering) */
const PLAN_ORDER = { week:1, weekly:1, month:2, monthly:2, quarter:3, quarterly:3, year:4, yearly:4, annual:4 };

/** App state */
const state = {
  symbol: 'BTCUSDT',
  tf: '1d',
  plans: [],
  subscription_status: 'unknown', // 'active' | 'inactive' | 'unknown'
  chartReady: false,
  lastMarketPayload: null,
};

/** =========================
 *  Utilities
 *  ========================= */
function toast(msg, sub="") {
  const t = document.getElementById('toast');
  t.innerHTML = `<div>${msg}</div>` + (sub ? `<div class="t-muted">${sub}</div>` : "");
  t.style.display = 'block';
  clearTimeout(toast._timer);
  toast._timer = setTimeout(()=> t.style.display='none', 3600);
}

function setApiHealth(ok, text){
  const pill = document.getElementById('apiPill');
  const apiText = document.getElementById('apiText');
  pill.classList.toggle('off', !ok);
  apiText.textContent = `API: ${text}`;
}

function qs(id){ return document.getElementById(id); }

function normalizeTf(tf){
  const found = TIMEFRAMES.some(x=>x.key===tf);
  return found ? tf : TF_FALLBACK;
}

function formatMoney(amount, currency='USD'){
  // amount can be in cents or dollars depending on backend; try to infer.
  // If amount is large like 1990 -> cents; if 19.9 -> dollars.
  let v = Number(amount);
  if (Number.isFinite(v)) {
    if (v >= 50 && Number.isInteger(v)) v = v / 100; // heuristics: treat as cents
    return new Intl.NumberFormat('en-US', { style:'currency', currency }).format(v);
  }
  return String(amount);
}

/** =========================
 *  1) Plans: load + render + self-check
 *  ========================= */
async function loadPlans(){
  try{
    const res = await fetch(PRICES_ENDPOINT, { method:'GET' });
    if(!res.ok) throw new Error(`prices http ${res.status}`);
    const data = await res.json();

    // Expect: array of plans. Each plan should include:
    // { price_id, amount, currency, interval } OR stripe-like fields
    // We will map best-effort.
    const plans = Array.isArray(data) ? data : (data?.data || data?.prices || []);
    if(!Array.isArray(plans)) throw new Error('prices not array');

    // Normalize
    const normalized = plans.map(p=>{
      const intervalRaw = (p.interval || p.recurring?.interval || p.billing_period || p.plan_interval || '').toString().toLowerCase();
      // Some backends might use 'week','month','year' OR 'weekly','monthly', etc.
      let interval = intervalRaw;
      if(interval === 'week') interval = 'weekly';
      if(interval === 'month') interval = 'monthly';
      if(interval === 'year') interval = 'yearly';
      if(interval === 'quarter') interval = 'quarterly';

      // price id field variants
      const price_id = p.price_id || p.id || p.priceId || p.price || p.stripe_price_id;

      // amount variants
      const amount = p.amount ?? p.unit_amount ?? p.unitAmount ?? p.price_amount ?? p.display_amount;

      const currency = (p.currency || 'USD').toUpperCase();

      const nickname = p.nickname || p.name || p.product_name || p.product || '';

      // Provide default label fallback
      const prettyInterval =
        interval === 'weekly' ? 'Weekly' :
        interval === 'monthly' ? 'Monthly' :
        interval === 'quarterly' ? 'Quarterly' :
        interval === 'yearly' || interval === 'annual' ? 'Yearly' : (interval || 'Plan');

      const label = `${prettyInterval} — ${formatMoney(amount, currency)}`;

      return { price_id, amount, currency, interval, nickname, label, raw:p };
    })
    .filter(p=>!!p.price_id);

    // Stable order
    normalized.sort((a,b)=>{
      const ia = PLAN_ORDER[a.interval] ?? 99;
      const ib = PLAN_ORDER[b.interval] ?? 99;
      return ia - ib;
    });

    state.plans = normalized;

    renderPlans();
    selfCheckPlans();

  }catch(err){
    console.error(err);
    state.plans = [];
    renderPlans();
    selfCheckPlans();
    toast("Failed to load plans", String(err));
  }
}

function renderPlans(){
  const sel = qs('planSelect');
  sel.innerHTML = '';
  if(state.plans.length === 0){
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = 'No plans';
    sel.appendChild(opt);
    return;
  }
  for(const p of state.plans){
    const opt = document.createElement('option');
    opt.value = p.price_id;
    opt.textContent = p.label;
    sel.appendChild(opt);
  }
}

function selfCheckPlans(){
  const badge = qs('plansHealth');
  const err = qs('planError');

  if(state.plans.length === 4){
    badge.textContent = 'Plans OK';
    badge.classList.add('ok');
    badge.classList.remove('err');
    err.style.display = 'none';
  }else{
    badge.textContent = `Plans ${state.plans.length}/4`;
    badge.classList.add('err');
    badge.classList.remove('ok');
    err.style.display = 'block';
    console.error("Plans missing or extra:", state.plans);
  }
}

/** =========================
 *  2) Timeframe: render 8 options + load must include tf + fallback
 *  ========================= */
function renderTimeframes(){
  // select
  const sel = qs('tfSelect');
  sel.innerHTML = '';
  for(const tf of TIMEFRAMES){
    const opt = document.createElement('option');
    opt.value = tf.key;
    opt.textContent = tf.label;
    sel.appendChild(opt);
  }
  sel.value = state.tf;

  // pills (top toolbar)
  const bar = qs('tfPills');
  bar.innerHTML = '';
  for(const tf of TIMEFRAMES){
    const pill = document.createElement('div');
    pill.className = 'pill' + (tf.key === state.tf ? ' active' : '');
    pill.textContent = tf.label;
    pill.onclick = ()=>{
      setTimeframe(tf.key);
      // optional: auto-load on click
      loadMarket();
    };
    bar.appendChild(pill);
  }
}

function setTimeframe(tf){
  state.tf = normalizeTf(tf);
  qs('tfSelect').value = state.tf;
  // update pills
  renderTimeframes();
}

/** =========================
 *  3) Chart: candles/line + EMA/AUX + B/S overlay traces
 *  ========================= */
function initChart(){
  const layout = {
    paper_bgcolor: 'rgba(0,0,0,0)',
    plot_bgcolor: 'rgba(0,0,0,0)',
    margin: { l:55, r:15, t:10, b:35 },
    xaxis: {
      gridcolor: 'rgba(255,255,255,.06)',
      zerolinecolor: 'rgba(255,255,255,.08)',
      color: 'rgba(214,226,241,.85)',
    },
    yaxis: {
      gridcolor: 'rgba(255,255,255,.06)',
      zerolinecolor: 'rgba(255,255,255,.08)',
      color: 'rgba(214,226,241,.85)',
    },
    showlegend: false,
  };

  Plotly.newPlot('chart', [], layout, {
    displayModeBar: true,
    responsive: true,
  });

  state.chartReady = true;
}

/**
 * Expected market payload (best effort):
 * {
 *   symbol: "BTCUSDT",
 *   tf: "1d",
 *   candles: [{t, o,h,l,c}] OR [{time, open, high, low, close}] OR line points,
 *   ema: [{t, v}] optional,
 *   aux: [{t, v}] optional,
 *   signals: [{t, type:"B"|"S", price}] optional
 * }
 */
function buildTraces(payload){
  const candles = payload.candles || payload.ohlc || payload.data || [];
  const ema = payload.ema || payload.EMA || null;
  const aux = payload.aux || payload.AUX || null;
  const signals = payload.signals || payload.bs || payload.BS || [];

  // Normalize candle fields
  const xs = [];
  const os = [];
  const hs = [];
  const ls = [];
  const cs = [];

  for(const row of candles){
    const t = row.t ?? row.time ?? row.ts ?? row.date;
    const o = row.o ?? row.open;
    const h = row.h ?? row.high;
    const l = row.l ?? row.low;
    const c = row.c ?? row.close ?? row.value;

    if(t == null) continue;
    xs.push(t);
    os.push(o);
    hs.push(h);
    ls.push(l);
    cs.push(c);
  }

  // Main trace: if OHLC exists -> candlestick; else -> line
  let mainTrace;
  const hasOhlc = os.every(v=>v!=null) && hs.every(v=>v!=null) && ls.every(v=>v!=null) && cs.every(v=>v!=null);
  if(hasOhlc){
    mainTrace = {
      type: 'candlestick',
      x: xs, open: os, high: hs, low: ls, close: cs,
      increasing: { line: { width: 1 } },
      decreasing: { line: { width: 1 } },
      name: 'Price'
    };
  }else{
    mainTrace = {
      type:'scatter',
      mode:'lines',
      x: xs,
      y: cs.filter(v=>v!=null),
      line: { width: 2 },
      name:'Price'
    };
  }

  const traces = [mainTrace];

  // EMA trace (optional)
  const showEMA = qs('toggleEMA').checked;
  if(showEMA && Array.isArray(ema) && ema.length){
    const ex = ema.map(r=>r.t ?? r.time ?? r.ts ?? r.date).filter(v=>v!=null);
    const ey = ema.map(r=>r.v ?? r.value ?? r.y).filter(v=>v!=null);
    traces.push({
      type:'scatter',
      mode:'lines',
      x: ex,
      y: ey,
      line: { width: 2 },
      name:'EMA'
    });
  }

  // AUX trace (optional)
  const showAUX = qs('toggleAUX').checked;
  if(showAUX && Array.isArray(aux) && aux.length){
    const ax = aux.map(r=>r.t ?? r.time ?? r.ts ?? r.date).filter(v=>v!=null);
    const ay = aux.map(r=>r.v ?? r.value ?? r.y).filter(v=>v!=null);
    traces.push({
      type:'scatter',
      mode:'lines',
      x: ax,
      y: ay,
      line: { width: 2, dash:'dot' },
      name:'AUX'
    });
  }

  // === B/S overlay: independent traces, always attached on redraw ===
  if(Array.isArray(signals) && signals.length){
    const buys = signals.filter(s => (s.type || s.side || '').toString().toUpperCase() === 'B');
    const sells = signals.filter(s => (s.type || s.side || '').toString().toUpperCase() === 'S');

    const bx = buys.map(s=>s.t ?? s.time ?? s.ts ?? s.date).filter(v=>v!=null);
    const by = buys.map(s=>s.price ?? s.p ?? s.value ?? s.y).filter(v=>v!=null);

    const sx = sells.map(s=>s.t ?? s.time ?? s.ts ?? s.date).filter(v=>v!=null);
    const sy = sells.map(s=>s.price ?? s.p ?? s.value ?? s.y).filter(v=>v!=null);

    if(bx.length && by.length){
      traces.push({
        type:'scatter',
        mode:'markers+text',
        x: bx,
        y: by,
        text: bx.map(()=> 'B'),
        textposition:'top center',
        marker:{ size:10, color: 'rgba(46,229,157,1)' },
        name:'B'
      });
    }
    if(sx.length && sy.length){
      traces.push({
        type:'scatter',
        mode:'markers+text',
        x: sx,
        y: sy,
        text: sx.map(()=> 'S'),
        textposition:'bottom center',
        marker:{ size:10, color: 'rgba(255,92,108,1)' },
        name:'S'
      });
    }
  }

  return traces;
}

function renderChart(payload){
  state.lastMarketPayload = payload;

  const symbol = payload.symbol || state.symbol;
  const tf = payload.tf || state.tf;
  qs('chartTitle').textContent = `${symbol} · ${tf}`;

  const traces = buildTraces(payload);

  const layout = {
    paper_bgcolor: 'rgba(0,0,0,0)',
    plot_bgcolor: 'rgba(0,0,0,0)',
    margin: { l:55, r:15, t:10, b:35 },
    xaxis: { gridcolor:'rgba(255,255,255,.06)', color:'rgba(214,226,241,.85)' },
    yaxis: { gridcolor:'rgba(255,255,255,.06)', color:'rgba(214,226,241,.85)' },
    showlegend: false
  };

  // IMPORTANT: use Plotly.react so every redraw includes B/S overlay traces.
  Plotly.react('chart', traces, layout, { displayModeBar:true, responsive:true });
}

/** =========================
 *  Market: fetch with tf + fallback
 *  ========================= */
async function loadMarket(){
  const symbol = qs('symbolInput').value.trim() || 'BTCUSDT';
  const tf = normalizeTf(qs('tfSelect').value);

  state.symbol = symbol;
  state.tf = tf;
  renderTimeframes(); // keep pills consistent

  const url = `${MARKET_ENDPOINT}?symbol=${encodeURIComponent(symbol)}&tf=${encodeURIComponent(tf)}`;

  qs('loadBtn').disabled = true;
  qs('loadBtn').textContent = 'Loading…';

  try{
    const res = await fetch(url, { method:'GET' });

    if(!res.ok){
      // fallback on unsupported tf: revert to 1d
      if(tf !== TF_FALLBACK){
        toast("Timeframe not supported", `Fallback to ${TF_FALLBACK.toUpperCase()}`);
        setTimeframe(TF_FALLBACK);
        return await loadMarket(); // retry once with fallback
      }
      throw new Error(`market http ${res.status}`);
    }

    const payload = await res.json();

    // If backend responded with an explicit unsupported marker
    if(payload && payload.error && tf !== TF_FALLBACK){
      toast("Timeframe not supported", `Fallback to ${TF_FALLBACK.toUpperCase()}`);
      setTimeframe(TF_FALLBACK);
      return await loadMarket();
    }

    renderChart(payload);

  }catch(err){
    console.error(err);
    toast("Failed to load market data", String(err));
  }finally{
    qs('loadBtn').disabled = false;
    qs('loadBtn').textContent = 'Load';
  }
}

/** If overlays toggles change, redraw with last payload (keeps B/S always) */
function attachOverlayHandlers(){
  qs('toggleEMA').addEventListener('change', ()=>{
    if(state.lastMarketPayload) renderChart(state.lastMarketPayload);
  });
  qs('toggleAUX').addEventListener('change', ()=>{
    if(state.lastMarketPayload) renderChart(state.lastMarketPayload);
  });
}

/** =========================
 *  4) Subscription UI (2 lines + 1 button)
 *  =========================
 *  - If status is active => button becomes "Manage Subscription"
 *  - Else => "Subscribe & Start" using Checkout Session
 *
 *  NOTE:
 *  We do not assume a subscription status endpoint exists.
 *  If you have one (e.g. GET /billing/subscription-status?user_id=xxx),
 *  you can wire it into refreshSubscriptionStatus().
 */
function renderSubscriptionUI(){
  const line = qs('subLine');
  const btn = qs('subActionBtn');

  const st = state.subscription_status;
  if(st === 'active'){
    line.textContent = 'Status: Active';
    btn.textContent = 'Manage Subscription';
    btn.classList.remove('good');
    btn.classList.add('ghost');
  }else if(st === 'inactive'){
    line.textContent = 'Status: Inactive';
    btn.textContent = 'Subscribe & Start';
    btn.classList.remove('ghost');
    btn.classList.add('good');
  }else{
    line.textContent = 'Status: Unknown';
    btn.textContent = 'Subscribe & Start';
    btn.classList.remove('ghost');
    btn.classList.add('good');
  }
}

/**
 * Subscribe & Start:
 * POST /create-checkout-session
 * body: { price_id, user_id, email }
 * expects: { url } OR { sessionUrl } OR { checkout_url }
 */
async function subscribeAndStart(){
  const price_id = qs('planSelect').value;
  const user_id = qs('userIdInput').value.trim();
  const email = qs('emailInput').value.trim();

  if(!price_id){
    toast("Please select a plan", "No price_id");
    return;
  }
  if(!user_id){
    toast("User ID required", "Please input user_id before subscribing.");
    return;
  }

  qs('subActionBtn').disabled = true;
  qs('subActionBtn').textContent = 'Redirecting…';

  try{
    const res = await fetch(CHECKOUT_ENDPOINT, {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({
        price_id,
        user_id,
        email: email || undefined
      })
    });

    if(!res.ok) throw new Error(`checkout http ${res.status}`);
    const data = await res.json();

    const url = data.url || data.sessionUrl || data.checkout_url || data.checkoutUrl;
    if(!url) throw new Error("No checkout URL returned by backend");

    window.location.href = url;

  }catch(err){
    console.error(err);
    toast("Failed to start checkout", String(err));
  }finally{
    qs('subActionBtn').disabled = false;
    renderSubscriptionUI();
  }
}

/**
 * Manage Subscription:
 * If you have a portal endpoint, wire it here.
 * For now we show a toast, because your route list may not include it yet.
 */
async function manageSubscription(){
  toast("Manage Subscription", "Portal endpoint not configured in this front-end yet.");
}

/** One-button handler */
function attachSubscriptionHandler(){
  qs('subActionBtn').addEventListener('click', async ()=>{
    if(state.subscription_status === 'active'){
      await manageSubscription();
    }else{
      await subscribeAndStart();
    }
  });
}

/** =========================
 *  API health check (nice UX)
 *  ========================= */
async function checkApiHealth(){
  try{
    const res = await fetch(HEALTH_ENDPOINT, { method:'GET' });
    if(!res.ok) throw new Error(`health http ${res.status}`);
    const data = await res.json().catch(()=>null);

    // If your root returns {"build": "..."} we display it
    if(data && data.build){
      qs('buildInfo').textContent = `build: ${data.build}`;
    }

    setApiHealth(true, 'OK');
  }catch(err){
    console.warn(err);
    setApiHealth(false, 'OFF');
  }
}

/** =========================
 *  Boot
 *  ========================= */
function boot(){
  // default state
  state.symbol = qs('symbolInput').value.trim() || 'BTCUSDT';
  state.tf = '1d';

  // render tf controls
  renderTimeframes();

  // init chart
  initChart();

  // attach handlers
  qs('tfSelect').addEventListener('change', ()=> setTimeframe(qs('tfSelect').value));
  qs('loadBtn').addEventListener('click', loadMarket);
  attachOverlayHandlers();

  // subscription
  renderSubscriptionUI();
  attachSubscriptionHandler();

  // health + plans + initial market
  checkApiHealth();
  loadPlans();
  loadMarket();
}

boot();
</script>
</body>
</html>
